<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Databend结项报告</title>
    <url>/2024/09/16/Databend%E7%BB%93%E9%A1%B9%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>Databend的项目结束啦，这是结项报告，虽然内容不多（主要是因为语文功底不行，写不出多少文字），但是收获确实非常大的，真的很感谢这次机会<code>(*^▽^*)</code></p>
<span id="more"></span>

<h1 id="洪文丽-246460479-结项报告"><a href="#洪文丽-246460479-结项报告" class="headerlink" title="洪文丽-246460479-结项报告"></a>洪文丽-246460479-结项报告</h1><h2 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h2><ul>
<li><p>项目名称：支持 External Dictionaries</p>
</li>
<li><p>方案描述：为了提高Databend数据库的效率和数据一致性，可以引入数据字典功能，并开发相应的字典函数，使用户能够直接从Databend查询存储在MySQL、Redis等外部数据源的信息。通过创建数据字典和使用如<code>dict_get</code>这样的字典函数，Databend可以避免繁琐的数据导出和导入过程，确保数据的实时更新和准确性。这种设计简化了大量数据处理的复杂性，提供了强大的数据管理能力。</p>
</li>
<li><p>时间规划：</p>
<img src="/img/Databend/时间轴.png" alt="时间规划" height="50%"></li>
</ul>
<h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><ul>
<li><p>已完成工作：</p>
<ol>
<li>编写并提交了 RFC 文档，明确了技术架构、功能设计及实现细节</li>
<li>实现了对 <code>CREATE</code>、<code>DROP</code>、<code>SHOW</code> 等字典管理 SQL 语句的解析和执行支持，确保字典的增删查功能具备完整的 SQL 操作接口</li>
<li>支持字典元数据API</li>
<li>提供了常用字典函数（如 <code>dict_get</code>），支持用户从 MySQL、Redis 等数据源中直接检索数据并返回结果</li>
<li>支持将 Redis以及Mysql 作为数据源，并实现相关的DDL</li>
</ol>
</li>
<li><p>遇到的问题及解决方案：</p>
<ul>
<li>最初由于 Git 操作不熟练，经过导师指导，逐渐掌握了 Git 和 GitHub 的使用，提高了代码管理的效率。</li>
<li>在项目初期，由于开发环境较为复杂且对硬件资源需求较高，本地配置和运行时遇到了内存不足等问题。为了应对这一挑战，导师提供了一台高性能远程服务器作为编译和测试环境，大大提升了开发效率和代码调试的顺畅性。此外，我们通过 Docker 容器化环境进行分布式测试，以确保不同开发环节的兼容性。</li>
<li>我们计划使用<code>opendal</code>读取数据库中的数据，发现它需要数据库中的数据类型为<code>BLOB/TEXT</code>，与我们的预期效果不一致，但是导师说有问题可以慢慢优化，于是导师优化了<code>opendal</code>，使得它能够在我们项目中使用。</li>
<li>在对 <code>dict_get</code> 函数进行 MySQL 数据库数据读取测试时，我们通过 <code>mysql_srv</code> 模拟服务器响应。最初使用官方示例代码进行测试时，遇到编译错误。导师深入分析了问题根源，主要涉及客户端预处理语句的处理不当。通过改进请求和响应处理逻辑，修改了示例代码中的参数传递方式，最终使测试顺利通过。此外，添加了更多边缘测试用例，以确保该功能在不同数据场景下的稳定性。</li>
</ul>
</li>
<li><p>测试用例：</p>
<ol>
<li><p>在Databend创建&#x2F;删除&#x2F;查看Dictionary，以下为部分测试结果示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">statement ok</span><br><span class="line">CREATE DICTIONARY d(c1 VARCHAR NOT NULL, c2 VARCHAR NOT NULL) PRIMARY KEY c1 SOURCE(mysql(host=&#x27;localhost&#x27; port=&#x27;3306&#x27; username=&#x27;root&#x27; password=&#x27;1234&#x27; db=&#x27;db1&#x27; table=&#x27;test_table&#x27;))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query TT</span><br><span class="line">show create dictionary d</span><br><span class="line">----</span><br><span class="line">d CREATE DICTIONARY d ( c1 VARCHAR NOT NULL, c2 VARCHAR NOT NULL ) PRIMARY KEY c1 SOURCE(mysql(db=&#x27;db1&#x27; host=&#x27;localhost&#x27; password=&#x27;[HIDDEN]&#x27; port=&#x27;3306&#x27; table=&#x27;test_table&#x27; username=&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">statement ok</span><br><span class="line">DROP DICTIONARY IF EXISTS d;</span><br></pre></td></tr></table></figure>

<p>使用 <code>databend-sqllogictests</code> 工具来运行 SQL Logic Tests。SQL Logic Tests 是一种用于测试数据库查询正确性的测试套件，它包含了一系列的测试用例，用于验证数据库系统是否能够正确处理各种 SQL 查询。</p>
<p>如图所示，测试通过：</p>
<p>![dictionary_ddl](C:\Users\86182\Desktop\Databend\屏幕截图 2024-08-19 160032.png)</p>
</li>
<li><p>通过 <code>dict_get</code> 函数，能够高效地从从 Redis 和 MySQL 数据源中成功检索数据，并返回字典数据。以下为部分测试结果示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">statement ok</span><br><span class="line">CREATE OR REPLACE DICTIONARY d(key string not null, value string not null) PRIMARY KEY key SOURCE(redis(host=&#x27;127.0.0.1&#x27; port=&#x27;6379&#x27;))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query T</span><br><span class="line">SELECT dict_get(d, &#x27;value&#x27;, &#x27;b&#x27;)</span><br><span class="line">----</span><br><span class="line">b_value</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">statement ok</span><br><span class="line">CREATE OR REPLACE DICTIONARY d2(id int, name string, age uint16, salary float, active bool) PRIMARY KEY id SOURCE(mysql(host=&#x27;localhost&#x27; port=&#x27;3106&#x27; username=&#x27;root&#x27; password=&#x27;123456&#x27; db=&#x27;test&#x27; table=&#x27;user&#x27;));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query TIFT</span><br><span class="line">select dict_get(d2, &#x27;name&#x27;, 1), dict_get(d2, &#x27;age&#x27;, 1), dict_get(d2, &#x27;salary&#x27;, 1), dict_get(d2, &#x27;active&#x27;, 1)</span><br><span class="line">----</span><br><span class="line">Alice 24 100.0 1</span><br></pre></td></tr></table></figure>

<p>如图所示，测试通过：</p>
<p>![dict_get_func](C:\Users\86182\Desktop\Databend\屏幕截图 2024-09-12 152921.png)</p>
</li>
</ol>
</li>
<li><p>后续工作安排：</p>
<p>后续我们将逐步扩展对 MySQL 中复杂数据类型（如 Date、Timestamp）的支持，以满足更多时间相关查询的需求。此外，项目计划进一步集成 PostgreSQL、ClickHouse 等常用数据库作为外部字典数据源，并对 NoSQL 数据库进行探索性研究，增强系统在多样化数据场景中的兼容性和扩展性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Databend</category>
      </categories>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2024/08/24/Docker/</url>
    <content><![CDATA[<p>这是一篇在B站尚硅谷那学到的Docker笔记</p>
<span id="more"></span>

<blockquote class='blockquote-center'><p>人类的悲欢并不相通，我只觉得他们吵闹。<br><strong>——鲁迅</strong></p>
</blockquote>

<h1 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h1><p>系统平滑移植，容器虚拟化技术，软件可以带环境安装。</p>
<p>通过<strong>镜像</strong>将业务系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台运作。</p>
<img src="/img/Docker/docker介绍.png" alt="Docker介绍" height="50%">

<ul>
<li>传统虚拟机技术虚拟出一套硬件，在其上运行一个完整的操作系统，再运行所需应用进程；</li>
<li>容器内的应用进程直接运行于宿主的内核，容器没有自己的内核也没有硬件虚拟，容器比虚拟机更为轻便，每个容器都有自己的文件系统；</li>
</ul>
<p><a href="https://www.docker.com/">Docker: Accelerated Container Application Development</a></p>
<p><a href="https://github.com/docker-archive/docker-ce">GitHub - docker-archive&#x2F;docker-ce: :warning: This repository is deprecated and will be archived (Docker CE itself is NOT deprecated) see the https://github.com/docker/docker-ce/blob/master/README.md :warning:</a></p>
<p><a href="https://hubgw.docker.com/">Docker Hub Container Image Library | App Containerization</a></p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><img src="/img/Docker/安装前提.png" alt="安装前提" height="50%">
<img src="/img/Docker/安装教程.png" alt="安装教程" height="50%">

<h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>只读的模板，可以用来创建Docker容器，一个镜像可以创建很多容器。</p>
<p>Java类模板</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>new 的实例对象，用镜像创的运行实例。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>集中存放镜像文件的场所，类似于Maven、GitHub</p>
<p>Docker Hub存放各种镜像模板。</p>
<p><a href="https://cloud.tencent.com/developer/article/1768295">图解 Docker 架构-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<img src="/img/Docker/Docker架构图.png" alt="Docker架构图" height="50%">

<ul>
<li>启动Docker:<code>systemctl start docker</code></li>
<li>终止Docker:<code>systemctl stop docker</code></li>
<li>卸载：<ul>
<li><code>yum remove docker-ce docker-ce-cli containerd.io</code></li>
<li><code>rm -rf /var/lib/docker</code></li>
<li><code>rm -rf /var/lib/containerd</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Beautiful photos</title>
    <url>/2024/09/14/%E6%88%91%E7%9A%84%E7%BE%8E%E7%85%A7/</url>
    <content><![CDATA[<p>今天去中街拍了个写真，算是一次大胆的尝试，因为试了四种风格，和平时的我非常不一样，这里就放四种风格里我觉得每种风格里最好看的一张(可都是没有P过的高清相机原图哦)，在博客里放自己的照片，我是不是太自恋了<code>⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄</code></p>
<span id="more"></span>

<p>第一张是纯欲风，看上去我非常的楚楚动人，背景也很干净，显得我人就干净了许多，但是这件衣服从前面看上去一切正常，但是后面是一整个大露背，不过也没拍到。</p>
<img src="/img/life/first.jpg" alt="纯欲风" height="50%">

<p>第二张是港风，拍起来真的好有感觉，就像我是那种有很多故事的成熟御姐，是我喜欢的风格，但是舍友说我不太适合这种风格，不过尝试一下还是非常好的。这件衣服前面就是一个深V，拍的时候胸贴都能开到，下摆还是个高开叉，直接开到大腿根，也就只能拍照穿穿了。</p>
<img src="/img/life/second.jpg" alt="港风" height="50%">

<p>第三张就是可爱风了，其实我不太喜欢这种风格，因为平时就是这种，但是舍友说我就适合这种，<code>(ಥ﹏ಥ)</code>，不过拍出来也挺好看的，主要是为了20岁生日的时候发个朋友圈<code>(*^▽^*)</code></p>
<img src="/img/life/third.jpg" alt="可爱风" height="50%">

<p>最后一张我看模特图还挺好看的，自己拍出来就满满的违和感，像是小孩穿了大人的衣服一样，一点都不合适，看来我的女强人梦破灭了，不过女强人也可以不穿西装的对吧，没错，<code>(#^.^#)</code></p>
<img src="/img/life/fourth.jpg" alt="职场风" height="50%">]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>First Try.</title>
    <url>/2024/09/13/hello-world/</url>
    <content><![CDATA[<p>介绍了如何启动该博客</p>
<span id="more"></span>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Databend项目申请书</title>
    <url>/2024/07/19/%E6%B4%AA%E6%96%87%E4%B8%BD-246460479-%E9%A1%B9%E7%9B%AE%E7%94%B3%E8%AF%B7%E4%B9%A6/</url>
    <content><![CDATA[<p>Databend的项目申请书，第一次做项目其实挺紧张的，怕做不好，为了这个项目我还去咨询了学长应该怎么做项目，希望能够顺利把。</p>
<span id="more"></span>

<h1 id="项目申请书"><a href="#项目申请书" class="headerlink" title="项目申请书"></a>项目申请书</h1><ul>
<li>项目名称：《支持 External Dictionaries》</li>
<li>项目主导师：<a href="b41sh%3Cbaishen@datafuselabs.com">b41sh&lt;baishen@datafuselabs.com</a></li>
<li>申请人：洪文丽</li>
<li>日期：2024年5月22日</li>
<li>邮箱：<a href="mailto:1853168638@qq.com;">1853168638@qq.com;</a></li>
</ul>
<h2 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1. 项目背景"></a>1. 项目背景</h2><p>external dictionary 的主要功能是让 databend 可以接入并访问其他外部数据源的数据，例如 （MySQL、PostgreSQL 等），丰富 databend 的生态。</p>
<p>假设我们有一个 MySQL 的数据库，里面有这样一张表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_info(</span><br><span class="line">  user_id <span class="type">int</span>,</span><br><span class="line">  user_name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  user_address <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;beijing&#x27;</span>),(<span class="number">2</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;andy&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果想在 Databend 访问这些数据，需要将 MySQL 的数据导出，再导入到 Databend 数据库。如果数据量很大，这样的操作会非常麻烦，同时如果数据经常发生变化，导入不及时也会造成数据的不一致。</p>
<p>external dictionary 就是为了解决这类问题，让 databend 可以方便的接入其他数据库的数据，通过创建 dictionary 来直接访问外部数据源。</p>
<p><strong>接入多种数据库所带来的好处：</strong></p>
<ul>
<li>实时性：当外部数据库中数据发生改变时，手动导入的数据可能和源数据不一致，而如果采用external dictionary让databend接入到外部数据库就能实现数据的实时修改，从而保证数据的最新性</li>
<li>简化数据管理：通过直接访问外部数据源，可以避免复杂的 ETL流程，简化了数据管理的工作。</li>
<li>灵活性更高：通过接入不同的数据库能够让企业不同类型的数据使用更合适的数据库进行存储。</li>
<li>数据整合：当企业需要整合存储在不同数据库中的数据时，就可以通过databend把不同数据库的数据都取出来进行分析。</li>
</ul>
<h2 id="2-技术的可行性"><a href="#2-技术的可行性" class="headerlink" title="2. 技术的可行性"></a>2. 技术的可行性</h2><p>Databend 使用 Rust 语言开发，对主流数据库都有成熟的 driver 支持，以MySql和postgresql为例。 </p>
<ul>
<li><p>MySql的驱动</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">mysql = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql::*;</span><br><span class="line"><span class="keyword">use</span> mysql::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    customer_id: <span class="type">i32</span>,</span><br><span class="line">    amount: <span class="type">i32</span>,</span><br><span class="line">    account_name: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::result::<span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;mysql://root:password@localhost:3306/db_name&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = Pool::<span class="title function_ invoke__">new</span>(url)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">conn</span> = pool.<span class="title function_ invoke__">get_conn</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个临时的 payments 表</span></span><br><span class="line">    conn.<span class="title function_ invoke__">query_drop</span>(</span><br><span class="line">        <span class="string">r&quot;CREATE TEMPORARY TABLE payment (</span></span><br><span class="line"><span class="string">            customer_id int not null,</span></span><br><span class="line"><span class="string">            amount int not null,</span></span><br><span class="line"><span class="string">            account_name text</span></span><br><span class="line"><span class="string">        )&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">payments</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Payment &#123; customer_id: <span class="number">1</span>, amount: <span class="number">2</span>, account_name: <span class="literal">None</span> &#125;,</span><br><span class="line">        Payment &#123; customer_id: <span class="number">3</span>, amount: <span class="number">4</span>, account_name: <span class="title function_ invoke__">Some</span>(<span class="string">&quot;foo&quot;</span>.<span class="title function_ invoke__">into</span>()) &#125;,</span><br><span class="line">        Payment &#123; customer_id: <span class="number">5</span>, amount: <span class="number">6</span>, account_name: <span class="literal">None</span> &#125;,</span><br><span class="line">        Payment &#123; customer_id: <span class="number">7</span>, amount: <span class="number">8</span>, account_name: <span class="literal">None</span> &#125;,</span><br><span class="line">        Payment &#123; customer_id: <span class="number">9</span>, amount: <span class="number">10</span>, account_name: <span class="title function_ invoke__">Some</span>(<span class="string">&quot;bar&quot;</span>.<span class="title function_ invoke__">into</span>()) &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 payments 数据</span></span><br><span class="line">    conn.<span class="title function_ invoke__">exec_batch</span>(</span><br><span class="line">        <span class="string">r&quot;INSERT INTO payment (customer_id, amount, account_name)</span></span><br><span class="line"><span class="string">          VALUES (:customer_id, :amount, :account_name)&quot;</span>,</span><br><span class="line">        payments.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|p| params! &#123;</span><br><span class="line">            <span class="string">&quot;customer_id&quot;</span> =&gt; p.customer_id,</span><br><span class="line">            <span class="string">&quot;amount&quot;</span> =&gt; p.amount,</span><br><span class="line">            <span class="string">&quot;account_name&quot;</span> =&gt; &amp;p.account_name,</span><br><span class="line">        &#125;)</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中选择 payments 数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">selected_payments</span> = conn</span><br><span class="line">        .<span class="title function_ invoke__">query_map</span>(</span><br><span class="line">            <span class="string">&quot;SELECT customer_id, amount, account_name from payment&quot;</span>,</span><br><span class="line">            |(customer_id, amount, account_name)| &#123;</span><br><span class="line">                Payment &#123; customer_id, amount, account_name &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        )?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保 `payments` 等于 `selected_payments`</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(payments, selected_payments);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Yay!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>postgresql的驱动</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">postgres = <span class="string">&quot;0.19&quot;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> postgres::&#123;Client, NoTls&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = Client::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;host=localhost user=postgres&quot;</span>, NoTls)?;</span><br><span class="line"></span><br><span class="line">client.<span class="title function_ invoke__">batch_execute</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">    CREATE TABLE person (</span></span><br><span class="line"><span class="string">        id      SERIAL PRIMARY KEY,</span></span><br><span class="line"><span class="string">        name    TEXT NOT NULL,</span></span><br><span class="line"><span class="string">        data    BYTEA</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&quot;</span>)?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">name</span> = <span class="string">&quot;Ferris&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = None::&lt;&amp;[<span class="type">u8</span>]&gt;;</span><br><span class="line">client.<span class="title function_ invoke__">execute</span>(</span><br><span class="line">    <span class="string">&quot;INSERT INTO person (name, data) VALUES ($1, $2)&quot;</span>,</span><br><span class="line">    &amp;[&amp;name, &amp;data],</span><br><span class="line">)?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> client.<span class="title function_ invoke__">query</span>(<span class="string">&quot;SELECT id, name, data FROM person&quot;</span>, &amp;[])? &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span>: <span class="type">i32</span> = row.<span class="title function_ invoke__">get</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span>: &amp;<span class="type">str</span> = row.<span class="title function_ invoke__">get</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span>: <span class="type">Option</span>&lt;&amp;[<span class="type">u8</span>]&gt; = row.<span class="title function_ invoke__">get</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;found person: &#123;&#125; &#123;&#125; &#123;:?&#125;&quot;</span>, id, name, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-项目实现细节"><a href="#3-项目实现细节" class="headerlink" title="3. 项目实现细节"></a>3. 项目实现细节</h2><h3 id="3-1-SQL-语法支持"><a href="#3-1-SQL-语法支持" class="headerlink" title="3.1 SQL 语法支持"></a>3.1 SQL 语法支持</h3><p>DICTIONARY 通过如下的语法进行创建、删除、查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DICTIONARY user_info(</span><br><span class="line">  user_id UInt86,</span><br><span class="line">  user_name String,</span><br><span class="line">  user_address String</span><br><span class="line">)</span><br><span class="line"><span class="keyword">primary</span> key(user_id)</span><br><span class="line">SOURCE(MYSQL(</span><br><span class="line">  host <span class="string">&#x27;[localhost](http://localhost/)&#x27;</span></span><br><span class="line">  <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span></span><br><span class="line">  password <span class="string">&#x27;root&#x27;</span></span><br><span class="line">  db <span class="string">&#x27;db_name&#x27;</span></span><br><span class="line">  <span class="keyword">table</span> <span class="string">&#x27;table_name&#x27;</span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> DICTIONARIES;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DICTIONARY user_info;</span><br><span class="line"><span class="keyword">DROP</span> DICTIONARY user_info;</span><br></pre></td></tr></table></figure>

<p>databend 使用 nom <a href="https://crates.io/crates/nom">https://crates.io/crates/nom</a> 的库实现语法的解析，将深入的 SQL 转成 AST。</p>
<ul>
<li><p><strong>SQL</strong>是一种用于管理关系型数据库系统的标准化查询语言。它允许用户从数据库中检索、操作和管理数据，以及定义数据库结构。SQL 由一系列的命令组成，用于执行各种数据库操作，如查询数据、插入数据、更新数据、删除数据以及管理数据库对象等。</p>
</li>
<li><p><strong>Parser</strong>负责将用户提交的SQL查询语句转换为数据库能够理解和执行的内部结构。解析器的主要功能包括词法分析、语法分析、语义分析和生成查询计划。这些步骤确保SQL语句正确并优化其执行。</p>
<ul>
<li><strong>词法分析器</strong>：将输入的SQL字符串拆分为一个个称为“词法单元”（tokens）的基本组成部分。每个词法单元代表SQL语句中的一个基本元素，如关键词（例如SELECT、FROM）、标识符（例如表名、列名）、运算符（例如&#x3D;、&gt;）、字面值（例如字符串、数字）等。</li>
<li><strong>语法分析器</strong>：接收词法单元并将它们组合成一个树状结构，称为“语法树”或“解析树”。语法分析器根据SQL语法规则检查SQL语句的正确性，确保词法单元按正确的顺序和结构排列。</li>
<li><strong>语义分析器</strong>：检查解析树的语义正确性，即检查表名和列名是否存在、数据类型是否匹配、权限是否足够等。此阶段确保查询不仅在语法上正确，而且在语义上也是合理的。</li>
</ul>
</li>
</ul>
<p>在 Databend 的 parser 中，有几个重要的组件被用到，其中包括 <code>map</code>、<code>alt</code>、<code>tuple</code> 以及自定义的 <code>rule!</code> 宏。</p>
<ul>
<li><p><strong>map</strong>:用于将解析器解析出的数据转换为其他类型或格式。它接受两个参数：一个解析器和一个函数，用于将解析器的结果转换为另一种格式。在 Databend 中，map 组件经常用于将解析后的结果转换成 AST 结构。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> nom::&#123;<span class="literal">Err</span>,error::ErrorKind, IResult,Parser&#125;;</span><br><span class="line"><span class="keyword">use</span> nom::character::complete::digit1;</span><br><span class="line"><span class="keyword">use</span> nom::combinator::map;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parser</span> = <span class="title function_ invoke__">map</span>(digit1, |s: &amp;<span class="type">str</span>| s.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser.<span class="title function_ invoke__">parse</span>(<span class="string">&quot;123456&quot;</span>), <span class="title function_ invoke__">Ok</span>((<span class="string">&quot;&quot;</span>, <span class="number">6</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser.<span class="title function_ invoke__">parse</span>(<span class="string">&quot;abc&quot;</span>), <span class="title function_ invoke__">Err</span>(Err::<span class="title function_ invoke__">Error</span>((<span class="string">&quot;abc&quot;</span>, ErrorKind::Digit))));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>alt</strong>:用于在多个解析器之间进行选择。它接受两个或多个解析器作为参数，并依次尝试将输入数据解析为这些解析器中的一个，返回第一个成功解析的结果。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> nom::character::complete::&#123;alpha1, digit1&#125;;</span><br><span class="line"><span class="keyword">use</span> nom::branch::alt;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parser</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> IResult&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">  <span class="title function_ invoke__">alt</span>((alpha1, digit1))(input)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parser</span>(<span class="string">&quot;abc&quot;</span>), <span class="title function_ invoke__">Ok</span>((<span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parser</span>(<span class="string">&quot;123456&quot;</span>), <span class="title function_ invoke__">Ok</span>((<span class="string">&quot;&quot;</span>, <span class="string">&quot;123456&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parser</span>(<span class="string">&quot; &quot;</span>), <span class="title function_ invoke__">Err</span>(Err::<span class="title function_ invoke__">Error</span>(error_position!(<span class="string">&quot; &quot;</span>, ErrorKind::Digit))));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tuple</strong> :用于将多个解析器按顺序组合起来，形成一个元组。除了可以嵌套多个解析器之外，tuple 还支持使用 map 函数对解析结果进行转换。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> nom::sequence::tuple;</span><br><span class="line"><span class="keyword">use</span> nom::character::complete::&#123;alpha1, digit1&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parser</span> = <span class="title function_ invoke__">tuple</span>((alpha1, digit1, alpha1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parser</span>(<span class="string">&quot;abc123def&quot;</span>), <span class="title function_ invoke__">Ok</span>((<span class="string">&quot;&quot;</span>, (<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;def&quot;</span>))));</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parser</span>(<span class="string">&quot;123def&quot;</span>), <span class="title function_ invoke__">Err</span>(Err::<span class="title function_ invoke__">Error</span>((<span class="string">&quot;123def&quot;</span>, ErrorKind::Alpha))));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rule!</strong>:用于方便地定义复杂的解析规则。它通过组合各种解析器和操作符来构建复杂的语法规则。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> rule &#123;</span><br><span class="line">    ($($tt:tt)*) =&gt; &#123; nom_rule::rule!(</span><br><span class="line">        $crate::match_text,</span><br><span class="line">        $crate::match_token,</span><br><span class="line">        $($tt)*)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-元数据的存储"><a href="#3-2-元数据的存储" class="headerlink" title="3.2 元数据的存储"></a>3.2 元数据的存储</h3><p>DICTIONARY 的相关元信息会存储在 databend 的 meta 模块中，用于执行 SQL 查询时获取相关信息。</p>
<p>Protobuf 具有以二进制格式存储数据，序列化和反序列化的速度快，且支持多种编程语言，能够清晰地清晰地定义数据的结构等优势。因此databend 采用 protobuf 对数据进行编码，转为二进制结果存储到数据库中。</p>
<ul>
<li>protobuf结构体实例：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> databend.meta;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">DictionaryMeta</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> source = <span class="number">2</span>;</span><br><span class="line">  map&lt;<span class="type">string</span>, <span class="type">string</span>&gt; options = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Rust 中，我们可以使用 prost crate 将其编译为 Rust 代码。</p>
<p>Prost 是 Rust 语言的一个 Protocol Buffers 实现，它可以从 proto2 和 proto3 文件生成简单、符合 Rust 习惯、易读的 Rust 代码。</p>
<ul>
<li><p>添加依赖：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">prost</span> = <span class="string">&quot;0.9&quot;</span></span><br><span class="line"><span class="attr">prost-types</span> = <span class="string">&quot;0.9&quot;</span></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">prost-build</span> = <span class="string">&quot;0.9&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译 protobuf 文件</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    prost_build::<span class="title function_ invoke__">compile_protos</span>(&amp;[<span class="string">&quot;src/dictionary.proto&quot;</span>], &amp;[<span class="string">&quot;src/&quot;</span>]).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入生成的代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> dictionary &#123;</span><br><span class="line">    include!(<span class="built_in">concat!</span>(<span class="built_in">env!</span>(<span class="string">&quot;OUT_DIR&quot;</span>), <span class="string">&quot;/databend.meta.rs&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用生成的 Rust 结构体，并将其编码为 protobuf 格式的二进制数据</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> dictionary::DictionaryMeta;</span><br><span class="line"><span class="keyword">use</span> prost::Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 创建一个 DictionaryMeta 实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">options</span> = std::collections::HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    options.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;host&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;localhost&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    options.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;port&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;3306&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dictionary_meta</span> = DictionaryMeta &#123;</span><br><span class="line">        name: <span class="string">&quot;user_info&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        source: <span class="string">&quot;mysql&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        options,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 DictionaryMeta 实例编码为 protobuf 格式的二进制数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    dictionary_meta.<span class="title function_ invoke__">encode</span>(&amp;<span class="keyword">mut</span> buf)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 现在包含了 protobuf 格式的二进制数据</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Encoded protobuf data: &#123;:?&#125;&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二进制数据解码回 DictionaryMeta 实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">decoded</span> = DictionaryMeta::<span class="title function_ invoke__">decode</span>(&amp;*buf)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Decoded DictionaryMeta: &#123;:?&#125;&quot;</span>, decoded);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-DICTIONARY-数据的查询"><a href="#3-3-DICTIONARY-数据的查询" class="headerlink" title="3.3 DICTIONARY 数据的查询"></a>3.3 DICTIONARY 数据的查询</h3><p>对 DICTIONARY 数据的查询主要通过 dict_get(dict_name, dict_field, dict_id) 函数进行。</p>
<p>dict_get 有三个参数，第一个是字典的名字，第二个是查询的字段，第三个是查询字典的 id。</p>
<p>例如：<code>select dict_get(user_info, &#39;user_name&#39;, 1);</code> 返回 ‘tom’，如图所示为查询语句的执行流程。</p>
<p><img src="C:\Users\86182\Desktop\洪文丽\SQLPlanner执行流程.png" alt="SqlPlanner执行流程"></p>
<p>dict_get 函数的执行会经过如下几个阶段：</p>
<ol>
<li><p><strong>binder 阶段</strong>：主要负责绑定数据源，通过查询 meta 判断字典和查询的字段是否存在，如果参数都没有问题，会生成一个初始的Logical Plan。得到初始的 Logical Plan 后，优化器会对其进行改写和优化，最终生成一个可执行的 Physical Plan 。</p>
<ul>
<li><p><strong>逻辑计划</strong>是一种高层次的表示方式，它描述了查询操作的逻辑过程，但不涉及具体的执行细节。逻辑计划关注的是“做什么”，而不是“怎么做”。作为优化的基础，通过优化器将其转换为更高效的执行计划。下面使用Rust定义了一个逻辑计划结构体，该逻辑计划定义了查询的字段和返回值类型，源数据库的地址等信息，根据逻辑计划可以生成物理计划。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Dictionary</span> &#123;</span><br><span class="line"> <span class="comment">// dictionary name in meta</span></span><br><span class="line"> <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line"> <span class="comment">// dictionary field name</span></span><br><span class="line"> <span class="keyword">pub</span> field_name: <span class="type">String</span>,</span><br><span class="line"> <span class="comment">// dictionary primary name</span></span><br><span class="line"> <span class="keyword">pub</span> primary_name: <span class="type">String</span>,</span><br><span class="line"> <span class="comment">// dictionary primary key</span></span><br><span class="line"> <span class="keyword">pub</span> argument: <span class="type">Box</span>&lt;ScalarExpr&gt;,</span><br><span class="line"> <span class="comment">// dictionary field data type</span></span><br><span class="line"> <span class="keyword">pub</span> return_type: <span class="type">Box</span>&lt;DataType&gt;,</span><br><span class="line"> <span class="comment">// dictionary source type, MySQL, PostgreSQL, ..</span></span><br><span class="line"> <span class="keyword">pub</span> source_type: DictionarySourceType,</span><br><span class="line"> <span class="keyword">pub</span> host: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> user_name: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> password: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> db_name: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> table_name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑计划经过Optimizer进行树结构的优化，以获得更高的执行效率。Planner将优化后的逻辑计划转化成<strong>物理计划</strong>物理计划是对逻辑计划的具体实现描述，涉及查询执行的详细步骤和策略。物理计划关注的是“怎么做”。下面使用Rust定义了一个物理计划结构体，该物理计划定义了输入参数的 index 和输出 column 的 index，源数据库的地址等信息。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Dictionary</span> &#123;</span><br><span class="line"> <span class="comment">// A unique id of operator in a `PhysicalPlan` tree, only used for display.</span></span><br><span class="line"> <span class="keyword">pub</span> plan_id: <span class="type">u32</span>,</span><br><span class="line"> <span class="keyword">pub</span> input: <span class="type">Box</span>&lt;PhysicalPlan&gt;,</span><br><span class="line"> <span class="keyword">pub</span> dcitionary_funcs: <span class="type">Vec</span>&lt;DictionaryFunctionDesc&gt;,</span><br><span class="line"> <span class="comment">// Only used for explain</span></span><br><span class="line"> <span class="keyword">pub</span> stat_info: <span class="type">Option</span>&lt;PlanStatsInfo&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DictionaryFunctionDesc</span> &#123;</span><br><span class="line"> <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> func_name: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> output_column: IndexType,</span><br><span class="line"> <span class="keyword">pub</span> arg_index: IndexType,</span><br><span class="line"> <span class="keyword">pub</span> arg_expr: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> data_type: <span class="type">Box</span>&lt;DataType&gt;,</span><br><span class="line"> <span class="keyword">pub</span> field_name: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> primary_name: <span class="type">String</span>,</span><br><span class="line"> <span class="comment">// dictionary source type, MySQL, PostgreSQL, ..</span></span><br><span class="line"> <span class="keyword">pub</span> source_type: DictionarySourceType,</span><br><span class="line"> <span class="keyword">pub</span> host: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> user_name: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> password: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> db_name: <span class="type">String</span>,</span><br><span class="line"> <span class="keyword">pub</span> table_name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>执行阶段</strong>，执行计划在执行的时候会生成一个 sql ，例如 <code>select user_name from user_info where user_id = 12; </code>再调用外部的 MySQL 数据库查询数据，然后封装成结果返回。以下是执行过程：</p>
<ul>
<li><p>使用 sourc_type ，host 等字段连接远端数据库。</p>
</li>
<li><p>使用 name、field_name, primary_name 等字段生成查询等 SQL。</p>
</li>
<li><p>调用源数据库用这个 SQL 进行查询，获取返回的结果。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql::*;</span><br><span class="line"><span class="keyword">use</span> mysql::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DictionaryFunctionDesc</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> func_name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> output_column: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> arg_index: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> arg_expr: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_type: <span class="type">Box</span>&lt;DataType&gt;,</span><br><span class="line">    <span class="keyword">pub</span> field_name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> primary_name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> source_type: DictionarySourceType,</span><br><span class="line">    <span class="keyword">pub</span> host: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> user_name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> password: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> db_name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> table_name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dict_get</span>(func_desc: &amp;DictionaryFunctionDesc, id: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 1. 连接到 MySQL 数据库</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">connection_url</span> = <span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;mysql://&#123;&#125;:&#123;&#125;@&#123;&#125;/&#123;&#125;&quot;</span>,</span><br><span class="line">        func_desc.user_name, func_desc.password, func_desc.host, func_desc.db_name</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = mysql::Pool::<span class="title function_ invoke__">new</span>(connection_url)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">conn</span> = pool.<span class="title function_ invoke__">get_conn</span>()?;</span><br><span class="line">    <span class="comment">// 2. 生成查询 SQL</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = <span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;SELECT &#123;&#125; FROM &#123;&#125; WHERE &#123;&#125; = &#123;&#125;;&quot;</span>,</span><br><span class="line">        func_desc.field_name, func_desc.table_name, func_desc.primary_name, id</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3. 执行查询并获取结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Option</span>&lt;<span class="type">String</span>&gt; = conn.<span class="title function_ invoke__">query_first</span>(query)?;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="title function_ invoke__">Ok</span>(value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(<span class="string">&quot;No result found&quot;</span>.<span class="title function_ invoke__">into</span>()),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">func_desc</span> = DictionaryFunctionDesc &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user_info&quot;</span>),</span><br><span class="line">        func_name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;get_user_name&quot;</span>),</span><br><span class="line">        output_column: <span class="number">0</span>,</span><br><span class="line">        arg_index: <span class="number">1</span>,</span><br><span class="line">        arg_expr: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">        data_type: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(DataType &#123;</span><br><span class="line">            <span class="comment">// 初始化 DataType...</span></span><br><span class="line">        &#125;),</span><br><span class="line">        field_name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user_name&quot;</span>),</span><br><span class="line">        primary_name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user_id&quot;</span>),</span><br><span class="line">        source_type: DictionarySourceType::MySQL,</span><br><span class="line">        host: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;localhost&quot;</span>),</span><br><span class="line">        user_name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;root&quot;</span>),</span><br><span class="line">        password: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">        db_name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;example_db&quot;</span>),</span><br><span class="line">        table_name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user_info&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//查询user_id为12的用户</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user_id</span> = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">dict_get</span>(&amp;func_desc, user_id) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(user_name) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;User name: &#123;&#125;&quot;</span>, user_name),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>​	本项目申请书提出了在 Databend 数据库中支持 External Dictionaries 的计划。该功能将使 Databend 能够直接接入并访问外部数据源，例如 MySQL 和 PostgreSQL，从而丰富 Databend 的生态系统。</p>
<p>​	通过引入 External Dictionaries 功能，Databend 将能够实时访问和处理外部数据库中的数据。这一特性将解决传统数据导入方法中存在的数据一致性和实时性问题，避免繁琐的手动导入操作，确保数据始终最新。此外，该功能还将简化数据管理流程，减少对复杂 ETL 流程的依赖，提高数据处理的灵活性。</p>
<p>​	技术方面，Databend 使用 Rust 语言开发，对主流数据库驱动（如 MySQL 和 PostgreSQL）有成熟的支持。项目计划通过详细的技术实现方案，展示如何在 Databend 中集成这些外部数据库的访问功能。代码示例展示了使用 Rust 语言连接和操作 MySQL 数据库的具体步骤，证明了该项目的技术可行性。</p>
<p>​	总体而言，该项目的实施将显著增强 Databend 的数据处理能力和灵活性，为企业提供更加高效和便捷的数据管理与分析工具。通过实现对外部数据源的无缝接入，Databend 将能够更好地满足企业多样化的数据需求，提升其在实际应用中的竞争力和价值。</p>
<p>​	最后，非常感谢老师能够在百忙之中仔细查看我的项目申请书并给出修改意见，经过这段时间对Databend项目的深入了解，我越来越相信它能够在未来有更大的成就，成为主流数据库。同时也希望能够参与到Databend的建设中。</p>
<h1 id="逻辑计划与物理计划"><a href="#逻辑计划与物理计划" class="headerlink" title="逻辑计划与物理计划"></a>逻辑计划与物理计划</h1><p>在数据库查询中，逻辑计划和物理计划是查询优化过程中的两个关键阶段：</p>
<ol>
<li><p><strong>逻辑计划（Logical Plan）</strong>：</p>
<ul>
<li>逻辑计划是查询优化的第一阶段，它描述了查询的逻辑结构和操作，但不考虑具体的执行细节。</li>
<li>它是根据用户的 SQL 查询语句生成的，包含了查询的所有必要步骤，如选择（SELECT）、投影（PROJECT）、连接（JOIN）、聚合（AGGREGATE）等。</li>
<li>逻辑计划的主要目的是提供一个高层次的查询表示，它与数据存储的物理结构和数据库的具体实现无关。</li>
<li>逻辑计划可以被视为查询的“概念模型”，它需要进一步的转换才能成为可在数据库中实际执行的计划。</li>
</ul>
</li>
<li><p><strong>物理计划（Physical Plan）</strong>：</p>
<ul>
<li>物理计划是查询优化的第二阶段，它基于逻辑计划生成，包含了执行查询所需的具体步骤和资源。</li>
<li>物理计划考虑了数据库的存储结构、索引、统计信息和系统资源等，以确定最有效的执行策略。</li>
<li>它定义了操作的实际执行顺序，数据的访问路径（如使用哪个索引），以及数据在各个操作之间的传输方式。</li>
<li>物理计划的目标是将逻辑计划转换成一个高效的执行计划，以最小化查询的执行时间和资源消耗。</li>
</ul>
</li>
</ol>
<p>逻辑计划和物理计划之间的关系可以概括为：</p>
<ul>
<li>用户的 SQL 查询首先被解析和转换成逻辑计划。</li>
<li>逻辑计划经过优化，考虑不同的执行策略和转换规则。</li>
<li>根据优化结果，生成物理计划，这是实际执行查询的蓝图。</li>
<li>数据库执行引擎根据物理计划执行查询，检索数据。</li>
</ul>
<p>在复杂的查询中，逻辑计划可能包含多个步骤和子计划，每个步骤都可以有多个可能的物理实现。数据库查询优化器（Query Optimizer）的任务就是选择最佳的物理计划，以确保查询高效执行。</p>
]]></content>
      <categories>
        <category>Databend</category>
      </categories>
  </entry>
  <entry>
    <title>HappyState Night</title>
    <url>/2024/09/17/%E6%94%BE%E8%82%86%E4%BA%86%E4%B8%80%E5%9B%9E/</url>
    <content><![CDATA[<p>最近心情不是很好，没有学习的劲头，甚至于EMO的时候没有活下去的欲望，于是就出去喝了点，认识了两个姐姐，和他们聊的很开心，不过确实是喝多了<code>￣□￣｜｜</code></p>
<span id="more"></span>

<p>其实本来昨天晚上就想去的，虽然昨天和班长打了三个点羽毛球晚上又在健身房运动了一会，但这个心情还是不好，很emo特别想哭，应该说已经哭了，但是因为太累了，而且他带着学妹在那，我去不太合适，所以就今天晚上去放松放松。</p>
<p>刚到那的时候有点小尴尬，因为旁边的人都是成双成对的，我一个人略显突兀，不过好在老板比较能说话，介绍了他在苏州的旅居生活，还挺羡慕他的，感觉他活得很自由，做着自己喜欢的事情，每天都能遇到各种各样的人，了解到各种各样的生活。</p>
<p>后来和旁边的姐姐搭上话了，她是个非常好的姐姐，懂很多道理，她说‘答案藏在时间里’让我不要迷茫，就珍惜眼下，该努力就努力，该放松就放松。后来她还请我吃了绝味<code>(*^▽^*)</code></p>
<p>雷友素催我回去了，我也喝的差不多了，头挺晕的了已经，再多喝一点就要吐了，赶紧回去吧！！！</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
</search>
